---
title: | 
  Análise Gráfica no R
  ![](images/logo.jpg){width=100px style="display:block; margin:0 auto"}
author: 
  - Costa, W. G.^[Weverton Gomes da Costa, Pós-Doutorando, Departamento de Estatística - UFV, wevertonufv@gmail.com]
date: "`r Sys.Date()`"
url: https://wevertongomescosta.github.io/Manipulacao-dados-e-Analise-Grafica-R/manipulacaodedados
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

Agora que já aprendemos algumas técnicas de manipulação de dados, vamos começar a explorar como criar gráficos usando o pacote `ggplot2` do tidyverse. Nesta seção, vamos aprender a sintaxe básica para criar um gráfico e como personalizá-lo para apresentar os resultados de forma clara e informativa.

Primeiro vamos instalar todos os pacotes necessários para leitura dos dados e produção dos gráficos:

```{r, eval=FALSE}
install.packages(
  c(
    "tidyverse",
    "DataExplorer",
    "metan",
    "readxl",
    "ggpmisc",
    "gridExtra",
    "extrafont",
    "ggpubr",
    "ggthemes"
  )
)
```

Agora vamos carregar os pacotes usando as funções `library()`:

```{r, message=FALSE}
library(tidyverse)
library(DataExplorer)             # Útil para análise exploratória
library(metan)                    # Possui ótimos gráficos de correlação e para análise exploratória
library(readxl)                   # Leitura de dados no formato .xlsx
library(ggpmisc)                  # Adicioanr o modelo na regressão
library(gridExtra)                # Agrupar gráficos
library(extrafont)                # Pacote para alterar a fonte do texto
library(ggpubr)                   # fornece algumas funções fáceis de usar para criar e personalizar gráficos
library(ggthemes)                 # Temas e paletas de cores
```

Vamos importar os dados exemplos que utilizaremos:

```{r}
dados <- read_csv("data/dados.csv")       # Função para importar os dados

dados
```

## Sintaxe básica do `ggplot2`

Neste curso, vamos explorar o pacote `ggplot2`, uma das ferramentas mais poderosas do R para criar gráficos e visualizações de dados. O `ggplot2` é um pacote do R que permite a criação de gráficos estatísticos elegantes e complexos. Ele é baseado em uma gramática de gráficos, que permite ao usuário construir gráficos a partir de camadas de informação, adicionando progressivamente detalhes ao gráfico.

Para criar gráficos utilizando o pacote `ggplot2`, é necessário utilizar a função `ggplot()` e passar no mínimo três elementos:

-   O objeto principal que contém os dados;
-   A estética `aes()` que define as variáveis de cada eixo;
-   O objeto geométrico `geom_***()` que define a geometria que irá representar os dados no gráfico, como pontos, boxplot, linha, etc.

Recomendamos a leitura da documentação do pacote para mais detalhes sobre as funcionalidades disponíveis [Function reference do ggplot](https://ggplot2.tidyverse.org/reference/). 

Depois, adiciona-se camadas de informação para construir o gráfico. A estrutura básica de um gráfico com ggplot2 é:

```{r, eval=FALSE}
ggplot(data = <dados>) +
  <geom> +
  <estética> +
  <coordenadas>
```

-   `data`: conjunto de dados a ser utilizado no gráfico
-   `geom`: o tipo de geometria (ponto, linha, barra etc.) que será usada no gráfico
-   `estética`: as variáveis estéticas que serão usadas no gráfico (x, y, cor, forma etc.)
-   `coordenadas`: o sistema de coordenadas a ser usado no gráfico (cartesiano, polar etc.)

## Criando um gráfico básico

Primeiro, iremos praticar sobre como é feito os gráficos básicos e abordar a maioria das geometrias existentes no `ggplot2`. 

Após isso iremos refinar a estética do nosso gráfico com temas, cores, alteração de texto e disposição das variáveis, legendas, etc.

### Primeiro gráfico

Como já mencionado, o gráfico necessita de 3 informações básica, os dados (`dados`), a estética (`aes()`)e a forma geométrica de representação (`geom_***()`).

### Gráfico de dispersão

Para criar um gráfico de dispersão, vamos utilizar os nossos `dados` para representar uma dispersão (`geom_point()`) da variável `id` eixo x e `area` no eixo y.

Podemos criar esse gráfico de duas formas: inserindo o banco de dados diretamente na função `ggplot()` ou utilizando o operador `%>%` (pipe) para passar o banco de dados para a função `ggplot()`.

1 - Inserindo o banco de dados dentro da função `ggplot()`.

```{r}
ggplot(dados, aes(x = id, y = areat)) +
  geom_point()
```

2 - Utilizando o pipe `%>%`. Nesse caso, não há necessidade de inserir o banco de dados dentro da função `ggplot()`.

```{r}
dados %>%
  ggplot(aes(x = id, y = areat)) +
  geom_point()
```

Como visto no código acima, ao usar a função `ggplot()`, usamos o símbolo `+` para adicionar ou alterar o gráfico. Aqui adicionamos a dispersão dos dados, mas poderíamos adicionar qualquer outra forma geométrica.

### Adicionando elementos ao gráfico

Os gráficos criados com `ggplot2` podem ser personalizados de diversas formas, adicionando-se elementos como títulos, legendas, eixos e escalas de cores.

Por exemplo, o código abaixo adiciona um título ao gráfico de dispersão criado anteriormente:

```{r}
ggplot(data = dados, aes(x = id, y = areat)) +
  geom_point() +
  ggtitle("Gráfico de Dispersão")
```

### Escalas de cores e temas

O `ggplot2` permite a personalização de escalas de cores para os gráficos, bem como a utilização de diferentes temas visuais para os gráficos.

Por exemplo, o código abaixo cria um gráfico de dispersão com pontos coloridos pela variável `gen` e utiliza o tema "theme_bw":

```{r}
# criando um gráfico de dispersão com cor e tema personalizados
ggplot(data = dados, aes(x = id, y = areat, color = gen)) + 
  geom_point() +
  scale_colour_manual(values = c("red", "blue")) +
  ggtitle("Gráfico de Dispersão com Escala de Cores Personalizada") +
  theme_bw()
```

### Gráficos de Dispersão

Para criar um gráfico de dispersão com o `ggplot2`, utilizamos a função `geom_point()`, especificando as variáveis x e y na estética `aes()`. 
Por exemplo, o código abaixo cria um gráfico de dispersão simples com o dataset `dados`, utilizando as variáveis `id` e `areat`:

```{r}
ggplot(dados, aes(x = id, y = areat)) + 
  geom_point() +
  ggtitle("Gráfico de Dispersão Simples")
```

### Gráfico de linhas

Para criar um gráfico de linhas com o `ggplot2`, utilizamos a função `geom_line()`, especificando as variáveis x e y na estética `aes()`. 
Por exemplo, o código abaixo cria um gráfico de linhas simples com o dataset `dados`, utilizando as variáveis `trat` e `areat`:

```{r}
# criando um gráfico de linhas com ggplot2
ggplot(dados, aes(x = id, y = areat)) +
  geom_line() +
  ggtitle("Gráfico de Linhas Simples")
```

### Gráfico de Barras

Os gráficos de barras e colunas são utilizados para comparar a frequência, magnitude ou proporção de diferentes categorias. O `ggplot2` permite criar gráficos de barras e colunas com a função `geom_bar()`, que agrupa os dados por categoria e conta o número de observações em cada categoria. Por exemplo, o código abaixo cria um gráfico de barras mostrando o número de carros de diferentes marcas:

No entanto, essa função cria uma contagem dos dados, então devemos atribuir apenas uma estética `x` ou `y`.

```{r}
dados %>%
  ggplot(aes(x = areat, fill = gen)) +
  geom_bar(position = "dodge", width = 0.5) +
  ggtitle("Gráfico de Linhas Simples - Número de gen por areat")
```

Também utilizamos a função `fill` para colorir as barras de acordo com o `gen` (Inca e Predileta). Em seguida, utilizamos a função `geom_bar()` para criar o gráfico de barras, especificando o argumento `position = "dodge"` para mostrar as barras lado a lado. Além disso adicionamos a função `width = 0.5` para aumentar a largura das barras.

### Gráfico de Colunas

Para criar um gráfico de colunas usamos a função `geom_col()`.

```{r}
dados %>%
  ggplot(aes(x = id, y = areat, fill = gen)) +
  geom_col(width = 0.5) +
  ggtitle("Gráfico de Colunas Simples")
```

Observe que existe uma diferença sútil entre `geom_col` e `geom_bar`: `geom_col` mostra o valor para o eixo y baseado nos valores numa coluna no seu tibble; geom_bar gera os valores para o eixo y baseado no número de observações em cada grupo de seu tibble. 
Então `geom_bar` é um atalho para:

```{r}
dados %>%
  group_by(gen, areat) %>%
  tally() %>%
  ggplot() +
  geom_col(aes(x = areat, y = n, fill = gen), width = 0.5, position = "dodge") +
  ggtitle("Gráfico de Colunas Simples - Número de gen por areat")
```

Para que o gráfico de barras seja equivalente ao gráfico de colunas, atribuímos o argumento `stat="identity"` dentro da função `geom_bar()`. Aqui devemos especificar tanto o `x` ou `y`.

```{r}
dados %>%
  ggplot(aes(x = id, y = areat, fill = gen)) +
  geom_bar(stat = "identity",width = 0.5) 
```

### Adicionando etiquetas e valores nos gráficos

Podemos adicionar etiquetas e valores nos gráficos de barras e colunas com as funções `geom_text()` e `geom_label()`. A função `geom_text()` adiciona as etiquetas diretamente nas barras ou colunas, enquanto a função `geom_label()` adiciona etiquetas em caixas de texto com borda.

```{r}
# criando um gráfico de barras com etiquetas de valores
dados %>%
  ggplot(aes(x = id, y = areat, fill = gen)) +
  geom_bar(stat = "identity", width = 0.5) +
  geom_text(aes(label = round(areat, digits = 0), y = areat + 1),
            position = position_dodge(0.9),
            vjust = 0) +
  ggtitle("Áreat por id e gen")
```

Para adicionar etiquetas de valores às barras, usamos a função `geom_text()`. Especificamente, definimos a estética label para mostrar o valor da área arredondado para zero casas decimais e ajustamos a posição vertical (`y`) da etiqueta para que ela fique acima da respectiva barra. Além disso, usamos a função `position_dodge()` para ajustar a posição horizontal das etiquetas e garantir que elas não se sobreponham.

### Histograma

A função `geom_histogram()` é utilizada para criar gráficos de histograma ou de frequência. Ela conta a frequência dos dados, então devemos atribuir apenas uma estética `x` ou `y`.

```{r}
dados %>%
  ggplot(aes(x = areat)) +
  geom_histogram()
```

Podemos também utilizar o gráfico de histograma para verificar a função de distribuição dos dados. Abaixo, utilizamos a função `stat_function()` para plotar uma distribuição normal, que tem como argumentos a média e o desvio padrão dos dados.

```{r}
dados %>%
  ggplot(aes(x = areat)) +
  geom_histogram(aes(y = after_stat(density)), bins = 10, fill ="white", color = "black") +
  stat_function(
    fun = dnorm, 
    aes(colour = "red"), 
    args = list(mean = mean(dados$areat), sd = sd(dados$areat))
  )+
  guides(colour = "none")
```

O argumento `bins` em `geom_histogram()` foi adicionado para controlar o número de barras no gráfico. Também foi adicionado `fill ="white"` e `color = "black"` para mudar a cor das barras para branco com bordas pretas e `guides(colour = "none")` para remover a legenda da linha vermelha que foi adicionada em `stat_function()`.

`fill=` é para cor do preenchimento das barras e `color =` para a cor das bordas das barras

### Linha vertical e horizontal

Para plotar uma reta no gráfico, podemos utilizar a função `geom_vline()` para linhas verticais ou `geom_hline()` para linhas horizontais. 

No exemplo abaixo vamos calcular a média da `areat` e plotar a reta média. 

```{r}
dados %>%
  ggplot(aes(x = areat)) +
  geom_histogram(bins = 10, fill ="white", color = "black") +
  geom_vline(xintercept = mean(dados$areat), colour = "red", linetype = "longdash")
```

Agora podemos considerar apenas quais `areat` apresentam com contagem acima de 10.

```{r}
dados %>%
  ggplot(aes(x = areat, fill = gen)) +
  geom_histogram(bins = 10, fill ="white", color = "black") +
  geom_hline(yintercept = 10, colour = "blue", linetype = "dotted")
```

### Boxplot

O boxplot é um gráfico que permite visualizar a distribuição dos dados a partir dos quartis, mediana e outliers. Para construir um boxplot, usamos a função `geom_boxplot()`. Nesse tipo de gráfico também é necessário combinar dados contínuos `area` com dados categóricos `gen`.

```{r}
dados %>%
  ggplot(aes(y = area, x = gen, fill = gen)) +
  geom_boxplot(outlier.colour = "red")+
  geom_jitter(alpha = 0.2 , width = 0.1)+
  labs(x = "Gen", y = "Area", fill = "Gen") +
  scale_y_continuous(limits = c(0,600))+
  theme_minimal()
```

Nesse código, adicionamos uma camada `geom_jitter()` para mostrar os pontos individuais, com transparência `alpha` e largura `width`. Também adicionamos títulos para os eixos x e y e para a legenda com a função `labs()`. Limitamos o eixo y entre 0 e 600 com `scale_y_continuous()`. E, por fim, alteramos o tema do gráfico para um tema minimalista com a função `theme_minimal()`.

### Correlação

Os gráficos de correlação são úteis para visualizar a relação entre duas ou mais variáveis. Antes de plotar o gráfico, precisamos calcular a correlação entre as variáveis de interesse.

Vamos estimar a correlação das variáveis `sev1`, `sev2`, `sev3`, `area` e `areat`. Para isso, usaremos a função usaremos a função `corr_coef()`, do pacote `metan` [(mais informações sobre esse pacote)](https://tiagoolivoto.github.io/metan/index.html). A função retorna uma matriz de correlação das nossas variáveis.

```{r}
library(metan)

# Calcula a matriz de correlação das variáveis selecionadas
coef_cor <- corr_coef(dados %>%
                        select(sev1:areat))

# Exibe a matriz de correlação na tela
coef_cor
```

Para plotar o gráfico de correlação, usaremos a função `plot()`. Se quisermos alterar o tipo de disposição das variáveis para a parte superior do gráfico, podemos usar o argumento `type = "upper"`. Para não ocorrer a ordenação das variáveis de acordo com o valor da correlação, usamos `reorder = FALSE`. Podemos também alterar os textos dos eixos e do gráfico usando os argumentos `size.text.lab` e `size.text.cor`, respectivamente.

```{r}
# Plota o gráfico de correlação
plot(
  coef_cor,
  type = "upper",
  reorder = FALSE,
  size.text.lab = 14,
  size.text.cor = 5
)
```

Veja mais sobre as particularidades da função `plot()` [aqui](https://tiagoolivoto.github.io/metan/reference/plot.corr_coef.html).

Outra forma de visualizar a correlação entre as variáveis é pela função corr_plot(). Essa função permite a visualização gráfica e numérica de uma matriz de correlação. No exemplo abaixo, selecionamos apenas as variáveis `sev1`, `sev2`, `sev3`, `area` e `areat` para gerar o gráfico.

```{r}
# Plota o gráfico de correlação usando a função corr_plot()
dados %>%
  select(sev1:areat) %>%
  corr_plot(shape.point = 21,
          col.point = 'black',
          fill.point = 'orange',
          size.point = 2,
          alpha.point = 0.6,
          maxsize = 4,
          minsize = 2,
          smooth = TRUE,
          size.line = 1,
          col.smooth = 'black',
          col.sign = 'cyan',
          col.up.panel = 'black',
          col.lw.panel = 'black',
          col.dia.panel = 'black',
          pan.spacing = 0,
          lab.position = 'tl')
```

### Regressão

A análise de regressão é uma das técnicas estatísticas mais utilizadas para a modelagem de dados. Nesse tipo de análise, buscamos estabelecer uma relação entre uma variável resposta `y` e uma ou mais variáveis explicativas `x`.

Para produzir um gráfico de regressão no R, utilizamos a função `geom_smooth()`. 

Abaixo, apresentamos um exemplo de gráfico de dispersão com uma regressão linear entre as variáveis `areat` e `id`.

```{r}
dados %>%
  ggplot(aes(x = id, y = areat)) +
  geom_smooth()
```

Por padrão, essa função utiliza o método não-paramétrico "loess" e a fórmula "y ~ x". Entretanto, podemos definir os argumentos `method =`, que define qual método iremos utilizar, por exemplo `method = lm` para definir uma regressão linear entre `x` e `y`, `se=` que é um argumento lógico (ou seja, recebe `TRUE` ou `FALSE`) e indica se será representado o intervalo de confiança.

```{r}
dados %>%
  ggplot(aes(x = id, y = area)) +
  geom_smooth(method = lm, se = FALSE)
```

Se quisermos inserir a fórmula no gráfico, utilizamos a `stat_poly_eq` função do pacote `ggpmisc`, indicando que a estética da equação é `..eq.label..` e/ ou da correlação `..rr.label..`.

```{r}
library(ggpmisc)

dados %>%
  ggplot(aes(x = id, y = areat)) +
  geom_point(aes(fill = gen),
             shape = 21,
             size = 2.8,
             col = "black") +
  scale_fill_manual(values = c("#999999", "#E69F00")) +
  geom_smooth(method = "lm",
              se = FALSE,
              col = "tomato") +
  stat_poly_eq(formula = y ~ x,
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~"))) +
  labs(x = "ID",
       y = "Area",
       fill = "Gen",
       title = "Gráfico de Regressão") +
  theme_light()
```

## Estética

### Escalas

As escalas são usadas para ajustar a exibição dos eixos X e Y em um gráfico. Elas permitem que você altere as unidades de medida, os intervalos, a orientação e a formatação dos rótulos dos eixos.

Existem diferentes maneiras de definir as escalas em um gráfico usando o pacote ggplot2 no R. Uma forma é usar as funções `xlim` e `ylim` para definir os limites dos eixos X e Y, respectivamente. Outra forma é usar as funções `scale_x_continuous()` e `scale_y_continuous()` para dados contínuos, e `scale_x_discrete()` e `scale_y_discrete()` para dados categóricos.

Por exemplo, no código abaixo, usamos a função `ylim()` para definir o limite máximo do eixo Y como 60 e o limite mínimo como 0. E também usamos a função `xlim()` para definir o limite máximo do eixo X como 100 e o limite mínimo como 0:

```{r}
dados %>%
  ggplot(aes(x = id, y = areat)) +
  geom_point(aes(fill = gen),
             shape = 21,
             size = 2.8,
             col = "black") +
  scale_fill_manual(values = c("#999999", "#E69F00")) +
  geom_smooth(method = "lm",
              se = FALSE,
              col = "tomato") +
  stat_poly_eq(formula = y ~ x,
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~"))) +
  labs(x = "ID",
       y = "Area",
       fill = "Gen",
       title = "Gráfico de Regressão") +
  theme_light() +
  ylim(0, 60)+
  xlim(0,100)
```

No entanto, em alguns casos, você pode precisar ajustar os intervalos das escalas. Por exemplo, você pode querer que os intervalos dos eixos X e Y sejam exibidos em incrementos de 10 ou 20. Nesses casos, você pode usar as funções breaks e limits das funções `scale_x_continuous()` e `scale_y_continuous()`.

Por exemplo, o código abaixo ajusta os intervalos dos eixos X e Y para serem exibidos em incrementos de 20:

```{r}
p <- dados %>%
  ggplot(aes(x = id, y = areat)) +
  geom_point(aes(fill = gen),
             shape = 21,
             size = 2.8,
             col = "black") +
  scale_fill_manual(values = c("#999999", "#E69F00")) +
  geom_smooth(method = "lm",
              se = FALSE,
              col = "tomato") +
  stat_poly_eq(formula = y ~ x,
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~"))) +
  labs(x = "ID",
       y = "Area",
       fill = "Gen",
       title = "Gráfico de Regressão") +
  theme_light() +
  expand_limits(x = 0, y = 0) +
  scale_x_continuous(breaks = seq(0, 100, 20)) +
  scale_y_continuous(breaks = seq(0, 60, 20))

p
```

Na função scale_x_continuous() do código acima, temos as seguintes configurações:

-   `breaks`: define os valores a serem mostrados nos intervalos do eixo x. No exemplo, foram definidos intervalos de 20 em 20 até 100, utilizando a função `seq(0, 100, 20)`. Assim, o eixo x terá marcas em 0, 20, 40, 60, 80 e 100.

-   `limits`: define os limites do eixo x. No exemplo, foram definidos limites de 0 a 100, utilizando a função `xlim(0, 100)`.

-   `expand`: expande os limites do eixo em uma fração do comprimento total do eixo. No exemplo, a função `expand_limits(x = 0, y = 0)` é usada para garantir que o gráfico contenha o ponto (0,0) no eixo x e no eixo y. Assim, o gráfico terá a origem (0, 0) como ponto de referência.

Essas opções permitem controlar os limites e a aparência do eixo x do gráfico, incluindo os valores mostrados e a escala utilizada.

### Facetas

As facetas são uma forma de visualizar dados divididos em categorias. Elas permitem criar vários gráficos de uma vez só, um para cada categoria da variável especificada. Existem duas funções para criar facetas: `facet_grid()` ou `facet_wrap()`.

A função `facet_grid()` cria uma grade de gráficos, especificando as variáveis que serão usadas para criar as facetas e sua disposição na grade, utilizando os argumentos `rows` e `cols`, respectivamente. Já a função `facet_wrap()` cria uma única coluna ou linha de gráficos, com cada gráfico correspondendo a uma categoria da variável especificada.

```{r}
# Criando facetas por genótipo
p +
  facet_grid(rows = vars(gen))

# Criando facetas por genótipo e blocos
p +
  facet_grid(rows = vars(gen), cols = vars(blocos))
```

Também é possível criar escalas independentes para cada categoria utilizando o argumento `scales`, que pode ser definido como `free`, para escalas livres tanto para o eixo `x` quanto para o eixo `y`, `free_x`, para escalas livres para o eixo `x` e `free_y` para o eixo `y`.

```{r}
p +
  facet_grid(rows = vars(gen), cols = vars(blocos), scales = "free_x")
```

### Coordenadas 

Podemos alterar as coordenadas do gráfico utilizando a função coord_flip() para girar o gráfico.

```{r}
# Girar o gráfico
p +
  coord_flip()
```

Além de `coord_flip()`, o pacote ggplot2 também oferece outras funções para alterar as coordenadas dos gráficos, permitindo a criação de visualizações mais complexas.

Por exemplo, podemos utilizar a função `coord_cartesian()` para definir os limites dos eixos `x` e `y` do gráfico. Isso é útil quando queremos "zoom in" em uma parte específica do gráfico ou remover pontos ou linhas que estejam fora de uma determinada faixa de valores.

```{r}
p +
  coord_cartesian(xlim = c(20, 80), ylim = c(0, 50))
```

Também podemos utilizar a função `coord_polar()` para criar gráficos em coordenadas polares, onde os dados são plotados em um sistema de coordenadas circular.

```{r}
# Gráfico em coordenadas polares
dados %>% 
ggplot(aes(x = factor(sev1))) +
  geom_bar() +
  coord_polar(theta = "y")
```

### Temas

Nesta seção, você irá aprender sobre os diferentes temas que podem ser aplicados aos gráficos no R usando o pacote `ggplot2`. Alguns dos temas que serão cobertos incluem `theme_bw()`, `theme_light()`, `theme_linedraw()`, `theme_dark()`, `theme_minimal()`, `theme_classic()`, e outros temas disponíveis no pacote `ggthemes.``

```{r}
p + theme_bw()
p + theme_light()
p + theme_linedraw()
p + theme_dark()
p + theme_minimal()
p + theme_classic()
```

Outro temas você pode encontrar no pacote [`ggthemes`](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/).

### Texto e eixos

Nesta seção, você aprenderá como adicionar textos, títulos e nomes de eixos em seus gráficos.

- Textos

Para inserir textos no gráfico utilizamos o função `geom_text()`, indicando a posição no gráfico (x e y) e o texto (label) a ser inserido.

```{r}
p + geom_text(x = 50, y = 5, label = "texto que você quiser escrever")
```

Também é possível utilizar a função `geom_text_repel()` do pacote `ggrepel` para adicionar rótulos que não se sobrepõem a outras camadas do gráfico.

```{r}
library(ggrepel)

p + geom_text_repel(aes(label = trat))
```

- Títulos

Para inserir títulos no gráfico usamos a função `labs()`. Para alterar a posição do título usamos o argumento ``plot.title()` dentro da função `theme()`. 

Para alteração no texto sempre devemos especificar `element_text()`. *Isso vale para qualquer parte do gráfico, não apenas para o título.*

```{r}
p +
  labs(title = "Gráfico de Regrressão", subtitle = "Area por ID por Gen") +
  theme(plot.title = element_text(hjust = 0.5, color = "#0072B2"), # Centralizando o título element_text(hjust = 0.5) e Alterando  a cor do título            
  plot.subtitle = element_text()) # Por padrão o alinhamento é feito à esquerda
```

- Nome dos eixos

Para alterar o nomes dos eixos também usamos a função `labs()` e especificamos os elementos `y` e `x`.

```{r}
p +
  labs(
    title = "Aqui o seu título",
    subtitle = "Aqui o seu subtítulo",
    y = bquote("Produção (kg" ~ ha ^ -1 ~ ")"),
    # título do eixo y
    x = "Individuo"
  ) + # título do eixo x
  theme(plot.title = element_text(hjust = 0.5, color = "#0072B2"), # Centralizando o título element_text(hjust = 0.5) e Alterando  a cor do título            
  plot.subtitle = element_text()) # Por padrão o alinhamento é feito à esquerda
```

**Para adicionar equações em texto de qualquer parte do gráfico usamos a função `bquote()`. Para valores subescritos indicamos entre colchetes entre `~` : CO[2], por exemplo. Para valores superescritos indicamos o acento circunflexo entre `~`: ha ^ -1, por exemplo.**

### Legendas

Nesta seção, você aprenderá como adicionar, alterar e remover legendas em seus gráficos.

-   Posição

Para alterar a posição da legenda usamos o argumento `legend.position` dentro da função `theme()`. As posições podem ser `bottom` (inferior), `top` (superior), `left` (esquerda) e `right` (direita). 

```{r}
p + theme(legend.position = "top")
```

Para inserir a legenda dentro do gráfico temos que atribuir valores de posição de x e y dentro do gráfico. x vale de 0 (esquerda) a 1 (direita) e y vale de 0 (inferior) a 1 (superior). Assim se quisermos que a legenda fique na esquerda da parte superior podemos, por exemplo, especificar `legend.position = c(0.2, 0.8)`.

```{r}
p + theme(
  legend.position = c(0.8, 0.2),
  legend.background = element_rect(fill = "white", colour = "black")
)
```

O argumento `legend.background` permite alterar a cor de preencimento e do quadro da legenda.

- Remover legendas

Para remover legendas basta indicar o atributo indicador da legenda como `none` dentro da função `guides()`. No nosso caso, atribuímos `fill` para `geom_point()`, assim devemos especificar `guides(fill = "none")`.

```{r}
p + guides(fill = "none")
```

## Escalas de cores

As escalas de cores permitem representar uma variável numérica ou categórica por meio de cores em um gráfico. O ggplot2 fornece diversas opções para criar escalas de cores personalizadas.

### Escala de cor contínua
A escala de cor contínua é usada para representar variáveis numéricas e pode ser definida utilizando a função `scale_color_gradient()`. É possível definir os limites mínimo e máximo da escala de cores com os argumentos `low` e `high`, respectivamente. Por padrão, o ggplot2 define automaticamente os limites com base nos valores da variável.

```{r}
p +
  geom_point(aes(color = areat)) +
  scale_color_gradient(low = "white", high = "red")
```


### Escala de cor discreta

A escala de cor discreta é usada para representar variáveis categóricas e pode ser definida utilizando a função `scale_color_brewer()` em conjunto com o argumento palette que define a paleta de cores a ser usada.


```{r}
p + scale_fill_manual(values = c("#999999", "#E69F00"))
```

Também podemos especificar por paletas de cores já existentes em pacotes. [Aqui](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html) você pode visualizar algumas paletas de cores.

```{r}
p + scale_color_brewer(palette = "Set1")
```

O pacote [ggthemes](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) também possui vários temas e paletas que podem ser do seu interesse.

```{r}
library(ggthemes)

p + 
  scale_fill_gdocs() 
```

## Exportar o gráfico

Para exportar gráficos usamos a função `ggsave()`. Se o gráfico não foi salvo em um objeto como feito anteriormente como objeto `p`, a função `ggsave()` irá salvar o último gráfico em `Plots`. Os argumentos presentes são `filename` é o nome da imagem que irá ser salva, `units` é a unidade, se não especificado é salvo em pixel, `width` e `height` é a largura e altura da imagem, respectivamente; `dpi` é a resolução em pixel, por default é 300.

```{r}
ggsave(
  filename = "grafico.tiff",
  units = "cm",
  width = 12,
  height = 8,
  dpi = 300
)
```

Para salvar um gráfico salvo em um objeto você deve especificar o argumento `plot` na função `ggsave()`.

```{r}
ggsave(
  filename = "grafico.tiff",
  plot = p,
  units = "cm",
  width = 12,
  height = 8,
  dpi = 300
)
```

Também é possível salvar o gráfico em formatos diferentes, como PDF, SVG ou PNG

```{r}
ggsave("meugrafico.pdf", dpi = 300)
ggsave("meugrafico.svg", dpi = 300)
ggsave("meugrafico.png", dpi = 300)
```


## Análise exploratória de dados

Nesta seção, faremos uma análise exploratória dos dados, utilizando os pacotes `DataExplorer` e `metan`. Primeiramente, vamos importar os dados exemplos utilizando a função `read_csv()`.

Importar os dados exemplos

```{r}
dados <- read_csv("data/dados.csv")       # Função para importar os dados

dados <- dados %>% 
  mutate_at(vars("trat", "id", "gen", "blocos"), as.factor)

dados
```

A partir disso, podemos utilizar algumas funções do pacote DataExplorer para analisar os dados, tais como:

-   `plot_intro()`: que mostra o tipo de cada variável e a ocorrência de valores ausentes;
-   `plot_missing()`: que exibe o perfil dos valores ausentes;
-   `plot_bar()`: que exibe a distribuição das variáveis qualitativas;
-   `plot_histogram()`: que exibe a distribuição das variáveis quantitativas
-   `plot_density()`: que exibe a distribuição de densidade das variáveis quantitativas
-   `plot_qq()`: que exibe o quantil de todas a varaiveis contínuas
-   `plot_correlation()`: que exibe o mapa de calor de correlação geral
-   `plot_boxplot()`: que exibe um boxplot da distribuição contínua bivariada
-   `plot_scatterplot()`: que exibe um gráfico de dispersão com todos os outros recursos contínuos

Veja como utilizá-las abaixo:

```{r}
plot_intro(dados)

plot_missing(dados)

plot_bar(dados)

plot_bar(dados, with = "blocos")

plot_bar(dados, by = "gen")

plot_histogram(dados)

plot_density(dados)

plot_qq(dados)

plot_qq(dados, by ="gen")

plot_correlation(dados)

plot_boxplot(dados, by = "trat")

plot_scatterplot(dados, by = "trat")
```

O Pacote `metan` também fornece algumas funções utéis para análise exploratória dos dados:

-   `find_outliers()`: pode ser usada para identificar possíveis outliers em um dataframe;
-   `inspect()`: verifica um objeto data.frame em busca de erros que possam afetar o uso de funções. Por padrão, todas as variáveis são verificadas quanto à classe (numérica ou fator), valores ausentes e presença de possíveis outliers. A função retornará um aviso se os dados parecerem desbalanceados, tiverem valores ausentes ou possíveis outliers;
-   `ge_plot()`: Esta função produz um gráfico de linhas para uma interpretação gráfica da interação entre dois fatores. O eixo y contém o valor da variável selecionada. Um mapa de calor também pode ser criado;

```{r}
find_outliers(dados, var = areat, plots = TRUE)

dados %>%
  select(-id) %>%
  inspect(plot = TRUE)

ge_plot(dados, blocos, trat, areat)

ge_plot(dados, blocos, trat, areat, type = 2)
```

O ggplot2 é uma ferramenta poderosa para visualização de dados em R. Neste curso, você aprendeu os conceitos básicos da gramática de gráficos e como usar o pacote ggplot2 para criar gráficos elegantes e informativos. Com as habilidades aprendidas neste curso, você poderá criar visualizações de dados impactantes e atraentes para qualquer tipo de análise.

Aqui deixo para vocês alguns outros gráficos que podem ser produzidos pelo ggplot com algumas melhorias que podem ser realizadas e aprimoradas a seu gosto. Faça bom proveito.

## Gráficos Extras

### Histograma com alteração da posição da legenda

```{r}
yield <- read_excel("data/yield.xlsx")
data <- read_excel("data/data.xlsx")

# Count graph relating Growth type to year

data %>%
  ggplot() +
  geom_bar(aes(Year, fill = Growth_type)) +
  scale_fill_brewer(palette = "Set1") +
  labs(fill = "Growth type", x = "Year", y = "Count") +
  theme_classic() +
  theme(legend.position = c(0.1, 0.9),
        legend.background = element_rect(fill = "white"),
        legend.box.background = element_rect(color = "black", linewidth = 1)) 
```

### Histograma e linha em um só gráfico (3 eixos)

```{r}
#Transformando variáveis em fatores
yield$Year <- as.factor(yield$Year)

ggplot() +
  geom_bar(data = data, aes(as.factor(Year), fill = Growth_type), width = 0.8) +
  geom_line(data = yield, aes(x = Year, y = (Yield * (175 / 125000))), 
            group = 1, color = "#a50026", size = 1) +
  geom_point(data = yield, aes(x = Year, y = (Yield * (175 / 125000))), 
             group = 1, color = "#a50026", size = 2) +
  scale_y_continuous(name = "Count", 
                     sec.axis = sec_axis( ~ . * 125000 / 175, name = "Yield (Thousand Tons)")) +
  scale_fill_brewer(palette = "Dark2") +
  labs(fill = "Event Type", x = "Year") +
  theme_classic() +
  theme(legend.position = c(0.1, 0.9),
        legend.background = element_rect(fill = "white"),
        legend.box.background = element_rect(color = "black", linewidth = 0.5),
        axis.text.y = element_text(angle = 0, vjust = 0.5, hjust = 1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())
```

### Gráfico de colunas com texto 

```{r}
library(readxl)                   # Ler aquivos em .xls e .xlsx
library(tidyverse)                # Framework para manipulação e visualização de dados

dados <- read_excel("data/medias.xlsx")

dados %>%
  ggplot(aes(x = TRAT, y = mean, fill = TRAT)) +
  geom_col(position = position_dodge(width = 0.85), colour = 'black', alpha = 0.8, width = 0.85) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = .3, position = position_dodge(width = 0.85)) +
  geom_text(aes(y = mean + sd, label = group), position = position_dodge(width = 0.85), vjust = -0.5, size = 4) +
  scale_fill_brewer(palette = "Paired") +
  labs(y = "Produtividade do cafeeiro", x = "") +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        legend.title = element_blank(),
        legend.position = c(0.8, 0.9),
        legend.background = element_rect(fill = "white"),
        legend.box.background = element_rect(color = "black", linewidth = 0.5)) +
  guides(fill = guide_legend(title = "Tratamentos"))
```

### Gráfico de segmentos e pontos

```{r}
library(readxl)                   # Ler aquivos em .xls e .xlsx
library(tidyverse)                # Framework para manipulação e visualização de dados

imp_trait <- read_excel("data/imp.xlsx")

imp_trait %>%
  pivot_longer(1:2,
               names_to = "variable") %>%
  mutate(traitnames = fct_reorder(traitnames, value)) %>%
  ggplot(aes(x = traitnames, y = value)) +
  geom_point(aes(colour = variable, shape = variable), size = 4) +
  geom_segment(aes(
    x = traitnames,
    xend = traitnames,
    y = 0,
    yend = value
  )) +
  labs(y = "Increase in node purity", x = "") +
  scale_colour_manual(labels = c("Accuracy", "Gini Indice"), values = c("#0072B2", "#E69F00")) +
  scale_shape_discrete(labels = c("Accuracy", "Gini Indice")) +
  
  theme_minimal() +
  theme(
    legend.position = c(0.8, 0.15),
    legend.title = element_blank(),
    legend.background = element_rect(fill = "white", colour = "black"),
    legend.key.size = unit(0.5, "cm"),
    axis.text.y = element_text(
      angle = 15,
      vjust = 0.5,
      hjust = 1
    )
  ) +
  coord_flip()
```

### Gráfico de linhas e regressão não-linear

```{r}
progress <- read_excel("data/progress.xlsx")

ggplot(progress, aes(Iteration, progress[[1]])) +
  geom_line(color = "#00AFBB", size = 1) +
  stat_smooth(color = "#FC4E07",
              fill = "#FC4E07",
              method = "loess") +
  theme_minimal() +
  labs(y = colnames(progress[1]))
```

### Agrupando gráficos de boxplot

```{r}
herd_prod <- read.table("data/prod_herd.txt", header = T)
cv_prod1 <- read.table("data/prod_cv.txt", header = T)
cv_prod <- read.table("data/cv_prod.txt", header = T)
media_prod <- read.table("data/prod_med.txt", header = T)

h_p <- ggplot(data = herd_prod, mapping = aes(x = 1, y = h²)) +
  geom_boxplot(
    fill = "gold1",
    outlier.colour = "tomato3",
    outlier.shape = 19,
    outlier.size = 1.5
  ) +
  geom_jitter(width = 0.01,
              alpha = 0.2,
              height = 0.05) +
  xlab("h²") +
  xlim(0, 2) +
  ylim(0, 100) +
  ylab(NULL) +
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks = element_blank(),
    panel.ontop = FALSE,
    text = element_text(family = "Times New Roman", size = 14)
  )

cv_p <- ggplot(data = cv_prod, aes(x = 1, y = CV)) +
  geom_boxplot(
    fill = "#4271AE",
    outlier.colour = "red",
    outlier.shape = 19,
    outlier.size = 1.5
  ) +
  geom_jitter(width = 0.001, alpha = 0.2) +
  xlab("CV") +
  xlim(0, 2) +
  ylim(0, 60) +
  ylab(NULL) +
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks = element_blank(),
    text = element_text(family = "Times New Roman", size = 14)
  )

m_p <- ggplot(data = media_prod, aes(x = 1, y = med)) +
  geom_boxplot(
    fill = "seagreen1",
    outlier.colour = "tomato3",
    outlier.shape = 19,
    outlier.size = 1.5
  ) +
  geom_jitter(width = 0.01, alpha = 0.2) +
  xlab("μ") +
  xlim(0, 2) +
  ylim(0, 10) +
  ylab(NULL) +
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks = element_blank(),
    text = element_text(family = "Times New Roman", size = 14)
  )

prod <- ggarrange(h_p, cv_p, m_p, ncol = 3, nrow = 1)

p <- annotate_figure(prod,
                     top = text_grob(
                       bquote(underline(.("            Grain yield               "))),
                       face = "bold",
                       family = "Times New Roman",
                       size = 14
                     ))
p
```

### Dispersão e regressão com abline 

```{r}
graf <- read.table("data/face.txt", header = T)
graf$Variable <- as.factor(graf$Variable)

a <- c(
  "Coeficient_of_Variation" = "Coef. of Variation (%)",
  "Grain_yield" = bquote("Grain yield (kg" ~ ha ^ -1 ~ ")"),
  "Heritability" = "Heritability (%)"
)

facet_labeller <- function(variable, value) {
  return(a[value])
}

ggplot(graf, aes(
  x = Year,
  y = Average,
  color = as.factor(Study)
)) +
  geom_point() +
  geom_line() +
  facet_grid(Variable ~ ., scales = "free_y", labeller = facet_labeller) +
  scale_colour_discrete(name = "Environment",
                        labels = c("CELP", "CELB", "CEGR")) +
  scale_x_continuous(breaks = c(2000:2020)) +
  scale_y_continuous(expand = expansion(mult = 0.5, add = 0.5)) +
  geom_abline(
    data = graf,
    mapping = aes(slope = Slope, intercept = Intercept),
    color = "red"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45),
    strip.text.y = element_text(size = 8),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "bottom",
    text = element_text(family = "Times New Roman", size = 12)
  )
```

### Dispersão com regressão linear e equação

```{r}
graf %>%
  filter(Variable != "Coefficient_of_variation") %>% 
  mutate(
    Study = as.factor(Study)
  ) %>%
  ggplot(aes(x = as.numeric(Year), y = Average, colour = Study)) +
  geom_point() +
  stat_poly_line(se = FALSE) +
  stat_poly_eq(aes(label = after_stat(eq.label)),
               label.y = c(0.95, 0.9, 0.85),
               label.x = c(1, 1, 1)) +
  facet_wrap(~ Variable, ncol = 3, scales="free_y") +
  scale_x_continuous(breaks = c(2004:2017))+
  theme_bw() +
  theme(plot.title = element_text(size = 16, face = "bold"),
        axis.text.x = element_text(angle = 45)) +
  scale_color_gdocs() +
  labs(x = "Year",
       colour = "Study")
```

